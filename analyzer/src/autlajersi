 if(diff > averageDifference * 1.5)
        {
            outliers.push_back(mSnapshots[i+1]);

            std::cout << diff << " bytes allocated:" <<  std::endl; 

            /* ako su dva uzastopna snimka detaljna */
            if (mSnapshots[i+1]->tree != nullptr && mSnapshots[i]->tree != nullptr) 
            {
                std::map<std::string, int> previousInfo = getMapByTree(mSnapshots[i]->tree);
                std::map<std::string, int> currentInfo = getMapByTree(mSnapshots[i+1]->tree);

                /* za svaku putanju u drugom detaljnom stablu */
                for (auto xCurrent: currentInfo) 
                {
                    /* pronaci istu putanju u prethodnom, prvom detaljnom stablu */
                    auto xPrevious = previousInfo.find(xCurrent.first);
                    
                    /* ukoliko takvo nesto ne postoji, pronasli smo mesto nove alokacije */
                    if (xPrevious == previousInfo.end()) 
                    {
                        std::cout << "  " << xCurrent.first << std::endl;
                        break;
                    }

                    /* u suprotnom, ako postoji i razlika u bajtovim je jednaka upravo trazenoj, onda smo pronasli mesto nove alokacije  */
                    if (xCurrent.second - (*xPrevious).second == diff) 
                    {
                        std::cout << "  " << xCurrent.first << std::endl;
                        break;
                    }
                }
            }
        }